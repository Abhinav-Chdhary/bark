package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/debkanchan/bark/internal/results"
	"github.com/debkanchan/bark/internal/scanner"
)

const (
	exitSuccess = 0
	exitFound   = 1
	exitError   = 2
)

func main() {
	// Define CLI flags
	formatFlag := flag.String("format", "text", "Output format (text, json)")
	flag.StringVar(formatFlag, "f", "text", "Output format (text, json) - shorthand")

	pathFlag := flag.String("path", "", "Path to scan (optional, can be provided as argument)")
	flag.StringVar(pathFlag, "p", "", "Path to scan - shorthand")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Bark - Detect BARK comments in your code\n\n")
		fmt.Fprintf(os.Stderr, "Usage:\n")
		fmt.Fprintf(os.Stderr, "  bark [options] [path]              Scan for BARK comments\n")
		fmt.Fprintf(os.Stderr, "  bark git-hook install              Install git pre-push hook\n")
		fmt.Fprintf(os.Stderr, "  bark git-hook uninstall            Uninstall git pre-push hook\n\n")
		fmt.Fprintf(os.Stderr, "Arguments:\n")
		fmt.Fprintf(os.Stderr, "  path    Directory or file to scan (default: current directory)\n\n")
		fmt.Fprintf(os.Stderr, "Options:\n")
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\nExamples:\n")
		fmt.Fprintf(os.Stderr, "  bark                    # Scan current directory\n")
		fmt.Fprintf(os.Stderr, "  bark ./src              # Scan src directory\n")
		fmt.Fprintf(os.Stderr, "  bark -format json .     # Scan current directory with JSON output\n")
		fmt.Fprintf(os.Stderr, "  bark git-hook install   # Install pre-push hook\n")
		fmt.Fprintf(os.Stderr, "\nExit codes:\n")
		fmt.Fprintf(os.Stderr, "  0 - No BARK comments found\n")
		fmt.Fprintf(os.Stderr, "  1 - BARK comments found\n")
		fmt.Fprintf(os.Stderr, "  2 - Error occurred during scanning\n")
	}

	flag.Parse()

	// Check for subcommands
	if flag.NArg() > 0 && flag.Arg(0) == "git-hook" {
		if flag.NArg() < 2 {
			fmt.Fprintf(os.Stderr, "Error: git-hook requires a subcommand (install or uninstall)\n")
			fmt.Fprintf(os.Stderr, "Usage: bark git-hook install|uninstall\n")
			os.Exit(exitError)
		}

		subcommand := flag.Arg(1)
		switch subcommand {
		case "install":
			installGitHook()
		case "uninstall":
			uninstallGitHook()
		default:
			fmt.Fprintf(os.Stderr, "Error: Unknown git-hook subcommand '%s'\n", subcommand)
			fmt.Fprintf(os.Stderr, "Valid subcommands: install, uninstall\n")
			os.Exit(exitError)
		}
		return
	}

	// Determine the path to scan
	// Priority: positional argument > -p flag > current directory
	var scanPath string
	if flag.NArg() > 0 {
		// Use positional argument
		scanPath = flag.Arg(0)
	} else if *pathFlag != "" {
		// Use -p flag
		scanPath = *pathFlag
	} else {
		// Default to current directory
		scanPath = "."
	}

	// Validate format
	var formatter results.Formatter
	switch *formatFlag {
	case "text":
		formatter = results.NewTextFormatter()
	case "json":
		formatter = results.NewJSONFormatter()
	default:
		fmt.Fprintf(os.Stderr, "Error: Invalid format '%s'. Use 'text' or 'json'.\n", *formatFlag)
		os.Exit(exitError)
	}

	// Validate path exists
	_, err := os.Stat(scanPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Cannot access path '%s': %v\n", scanPath, err)
		os.Exit(exitError)
	}

	// Scan directory or file
	s := scanner.NewScanner()
	result := s.Scan(scanPath)

	// Format and print results
	output, err := formatter.Format(result)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting output: %v\n", err)
		os.Exit(exitError)
	}

	fmt.Print(output)

	// Check for errors during scanning
	errors := result.GetErrors()
	if len(errors) > 0 {
		os.Exit(exitError)
	}

	// Exit with code 1 if BARK comments found, 0 otherwise
	if result.HasFindings() {
		os.Exit(exitFound)
	}

	os.Exit(exitSuccess)
}

const (
	hookBeginMarker = "# BEGIN bark hook"
	hookEndMarker   = "# END bark hook"
	hookContent     = `#!/bin/sh
# BEGIN bark hook
# Generated by bark - https://github.com/debkanchan/bark
echo "üêï Running bark to check for BARK comments..."
bark .
if [ $? -eq 1 ]; then
    echo ""
    echo "‚ùå Push blocked: BARK comments found"
    echo "Please remove BARK comments before pushing"
    echo "Run 'bark .' to see all BARK comments"
    exit 1
fi
# END bark hook
`
)

func installGitHook() {
	// Check if we're in a git repository
	if _, err := os.Stat(".git"); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Error: Not in a git repository\n")
		fmt.Fprintf(os.Stderr, "Please run this command from the root of your git repository\n")
		os.Exit(exitError)
	}

	hookPath := filepath.Join(".git", "hooks", "pre-push")

	// Create backup if file exists
	if _, err := os.Stat(hookPath); err == nil {
		timestamp := time.Now().Format("20060102-150405")
		backupPath := hookPath + ".bak." + timestamp

		// Read existing file
		content, err := os.ReadFile(hookPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading existing hook: %v\n", err)
			os.Exit(exitError)
		}

		// Write backup
		if err := os.WriteFile(backupPath, content, 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error creating backup: %v\n", err)
			os.Exit(exitError)
		}

		fmt.Printf("üì¶ Backed up existing hook to: %s\n", backupPath)
	}

	// Read existing hook content
	var existingContent string
	if content, err := os.ReadFile(hookPath); err == nil {
		existingContent = string(content)
	}

	var newContent string

	// Check if bark section already exists
	if strings.Contains(existingContent, hookBeginMarker) && strings.Contains(existingContent, hookEndMarker) {
		// Replace existing bark section
		lines := strings.Split(existingContent, "\n")
		var result []string
		inBarkSection := false
		barkSectionReplaced := false

		for _, line := range lines {
			if strings.Contains(line, hookBeginMarker) {
				if !barkSectionReplaced {
					// Insert new bark section
					result = append(result, strings.TrimSuffix(hookContent, "\n"))
					barkSectionReplaced = true
				}
				inBarkSection = true
				continue
			}
			if strings.Contains(line, hookEndMarker) {
				inBarkSection = false
				continue
			}
			if !inBarkSection {
				result = append(result, line)
			}
		}
		newContent = strings.Join(result, "\n")
		fmt.Println("‚úÖ Updated existing bark hook section")
	} else if existingContent != "" {
		// Append bark section to existing hook
		newContent = strings.TrimRight(existingContent, "\n") + "\n\n" + hookContent
		fmt.Println("‚úÖ Added bark hook to existing pre-push hook")
	} else {
		// Create new hook file
		newContent = hookContent
		fmt.Println("‚úÖ Created new pre-push hook with bark")
	}

	// Write the hook file
	if err := os.WriteFile(hookPath, []byte(newContent), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing hook file: %v\n", err)
		os.Exit(exitError)
	}

	fmt.Println("\nüéâ Git hook installed successfully!")
	fmt.Println("Bark will now check for BARK comments before each push")
}

func uninstallGitHook() {
	hookPath := filepath.Join(".git", "hooks", "pre-push")

	// Check if hook file exists
	if _, err := os.Stat(hookPath); os.IsNotExist(err) {
		fmt.Println("‚ÑπÔ∏è  No pre-push hook found - nothing to uninstall")
		os.Exit(exitSuccess)
	}

	// Read the hook file
	content, err := os.ReadFile(hookPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading hook file: %v\n", err)
		os.Exit(exitError)
	}

	hookContent := string(content)

	// Check if bark section exists
	if !strings.Contains(hookContent, hookBeginMarker) || !strings.Contains(hookContent, hookEndMarker) {
		fmt.Println("‚ÑπÔ∏è  No bark hook found in pre-push - nothing to uninstall")
		os.Exit(exitSuccess)
	}

	// Create backup
	timestamp := time.Now().Format("20060102-150405")
	backupPath := hookPath + ".bak." + timestamp
	if err := os.WriteFile(backupPath, content, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating backup: %v\n", err)
		os.Exit(exitError)
	}
	fmt.Printf("üì¶ Backed up existing hook to: %s\n", backupPath)

	// Remove bark section
	scanner := bufio.NewScanner(strings.NewReader(hookContent))
	var result []string
	inBarkSection := false

	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, hookBeginMarker) {
			inBarkSection = true
			continue
		}
		if strings.Contains(line, hookEndMarker) {
			inBarkSection = false
			continue
		}
		if !inBarkSection {
			result = append(result, line)
		}
	}

	newContent := strings.Join(result, "\n")
	newContent = strings.TrimSpace(newContent)

	// If file is now empty or only has shebang, delete it
	if newContent == "" || newContent == "#!/bin/sh" || newContent == "#!/bin/bash" {
		if err := os.Remove(hookPath); err != nil {
			fmt.Fprintf(os.Stderr, "Error removing hook file: %v\n", err)
			os.Exit(exitError)
		}
		fmt.Println("‚úÖ Removed pre-push hook (file was empty after bark removal)")
	} else {
		// Write the modified content back
		if err := os.WriteFile(hookPath, []byte(newContent+"\n"), 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing hook file: %v\n", err)
			os.Exit(exitError)
		}
		fmt.Println("‚úÖ Removed bark section from pre-push hook")
	}

	fmt.Println("\nüéâ Bark git hook uninstalled successfully!")
}
